<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>InkWell</title>
  <link href="https://fonts.googleapis.com/css2?family=Alice&display=swap" rel="stylesheet" />
  <style>
    :root {
      --title-font: 'Helvetica Neue', sans-serif;
      --body-font: 'Alice', serif;
      --dark-title: #2A2A2A;
      --dark-text: #555555;
      --light-text: #999999;
    }

    .btn {
  margin-top: 0.5em;
  padding: 0.5em 1em;
  font-size: 0.95em;
  background-color: #FFA76D;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
.btn:hover {
  background-color: #e8965e;
}

    h1, h2, h3, h4, h5 {
      font-family: var(--title-font);
      color: var(--dark-title);
      font-weight: 600;
    }

    p, label, input, textarea, button {
      font-family: var(--body-font);
      color: var(--dark-text);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --dark-title: #FFFFFF;
        --dark-text: #CCCCCC;
        --light-text: #999999;
      }

      h1, h2, h3, h4, h5 {
        color: var(--dark-title);
      }

      p, label, input, textarea, button {
        color: var(--dark-text);
      }

      /* Ensure journal entry preview text is visible when collapsed in dark mode */
      .entry-preview,
      .entry-preview * {
        color: #CCCCCC !important;
      }

      .coach-reply {
        background-color: #2a2a2a;
        border-left: 4px solid #FFA76D;
        color: #CCCCCC;
      }
    }

    body {
      margin: 0;
      font-family: var(--body-font);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2em;
    }
    /* Light mode styles */
    @media (prefers-color-scheme: light) {
      body {
        background-color: #EAF6FB;
        color: #2A6D6D;
      }
      main {
        background: white;
        color: inherit;
      }
      input,
      textarea {
        background-color: #fff;
        border: 1px solid #ccc;
      }
      button {
        background-color: #FFA76D;
        color: white;
      }
      button:hover {
        background-color: #e8965e;
      }
    }

    /* Dark mode styles */
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #1E1E1E;
        color: #CCCCCC;
      }
      main {
        background: #2A2A2A;
        color: inherit;
      }
      input,
      textarea {
        background-color: #333;
        border: 1px solid #666;
      }
      button {
        background-color: #FFA76D;
        color: white;
      }
      button:hover {
        background-color: #e8965e;
      }
      /* Override calendar text color for dark mode for better visibility */
      #calendarTab th,
#calendarTab td,
#calendarTab p,
#calendarTab h2,
#calendarTab h3 {
  color: var(--dark-text);
}
      /* Fix dark mode text color for Favorite Prompts block */
      #favoritePromptsList,
      #favoritePromptsList p,
      details summary {
        color: var(--dark-text);
      }
      /* Footer copyright and links dark mode override */
      footer,
      footer p,
      footer a {
        color: #EAF6FB !important;
      }
    }
    header {
      text-align: center;
      margin-bottom: 2em;
    }
    h1 {
      color: #FFA76D;
      font-size: 2.5em;
    }
    main {
      background: white;
      padding: 2em;
      border-radius: 10px;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      color: inherit;
    }
    textarea {
      width: 100%;
      height: 200px;
      padding: 1em;
      font-family: 'Alice', serif;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 5px;
      resize: vertical;
    }

    /* Flash confirmation animation for journal entry */
    .flash-confirmation {
      animation: flashHighlight 1s ease-in-out;
    }
    @keyframes flashHighlight {
      0% { background-color: #D4F5D0; }
      50% { background-color: #A1E3A1; }
      100% { background-color: transparent; }
    }

    .spinner {
  display: inline-block;
  width: 1em;
  height: 1em;
  border: 2px solid rgba(255, 167, 109, 0.3);
  border-top-color: #FFA76D;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 0.5em;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
    /* Mobile Responsive Styles */
    @media (max-width: 600px) {
      body {
        padding: 1em;
      }

      main {
        padding: 1em;
        max-width: 100%;
        border-radius: 0;
        box-shadow: none;
      }

      textarea {
        height: 150px;
      }

      button {
        width: 100%;
        font-size: 0.95em;
        padding: 0.5em;
      }

      header img {
        max-width: 100%;
        height: auto;
      }

      input[type="text"],
      input[type="date"],
      input[type="file"],
      textarea {
        font-size: 1em;
      }
    }
    html {
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    /* === InkWell Visual Theme Components === */
    .card-block {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 1em;
      margin-bottom: 2em;
      background-color: #f9f9f9;
    }

    /* Fullscreen overlay for Alpha Agreement modal - perfectly center modal */
    #embeddedAgreementNotice {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      
    }
    #embeddedAgreementNotice .card-block {
      background-color: #fff8f2;
      border: 2px dashed #FFA76D;
      max-width: 500px;
      width: 90%;
      min-width: 0;
      text-align: center;
      box-shadow: 0 0 24px rgba(0,0,0,0.15);
      margin: 0; /* Remove margin that could affect centering */
      padding: 2em 1.5em;
      box-sizing: border-box;
    }

    /* Ensure modal is centered on all screen sizes (mobile responsive) */
    @media (max-width: 600px) {
      #embeddedAgreementNotice .card-block {
        max-width: 98vw;
        width: 98vw;
        padding: 1.25em 0.5em;
      }
    }

    

    .card-block p {
  font-size: 1em;
  line-height: 1.6;
}
    .section-header {
      font-size: 1.2em;
      color: #2A6D6D;
      margin-top: 0;
      margin-bottom: 0.5em;
    }

    .subtext-muted {
      font-size: 0.85em;
      color: #CCCCCC;
      font-style: italic;
      margin-top: 0.25em;
    }

    .entry-preview {
  max-height: 4.5em;
  overflow: hidden;
  position: relative;
}
    .entry-preview::after {
  content: "...";
  position: absolute;
  bottom: 0;
  right: 0;
  background: linear-gradient(to right, transparent, white 50%);
}
#journalTabButton {
  background-color: #2A6D6D !important;
  color: white !important;
}
#calendarTabButton {
  background-color: #FFA76D !important;
  color: white !important;
}

  </style>
  <script type="module">
    // Firebase App (the core Firebase SDK) is always required
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
    import { getFirestore, collection, addDoc, serverTimestamp, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-storage.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-auth.js";
    import {
      createUserWithEmailAndPassword,
      signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-auth.js";


    // Firebase configuration for InkWell Alpha
    const firebaseConfig = {
      apiKey: "AIzaSyDivYKnp_SinGjL7iVVwSyQH-RnFHMFDM0",
      authDomain: "inkwell-alpha.firebaseapp.com",
      projectId: "inkwell-alpha",
      storageBucket: "inkwell-alpha.firebasestorage.app",
      messagingSenderId: "849610731668",
      appId: "1:849610731668:web:f06d1a63f0db6391674481",
      measurementId: "G-KHHZRVB7EJ"
    };

    const app = initializeApp(firebaseConfig);

    const db = getFirestore(app);

    const storage = getStorage(app);
    const auth = getAuth(app);
    

    // === SESSION MANAGEMENT: Auto-logout on close/refresh and inactivity ===
    // Helper: logout only if signed in
    async function safeLogout(reason) {
      if (auth.currentUser) {
        localStorage.setItem("userJustLoggedOut", "true");
        await auth.signOut();
        document.querySelector("main").style.display = "none";
        // Always hide the Alpha modal on logout
        document.getElementById("embeddedAgreementNotice").style.display = "none";
        setTimeout(() => {
          document.getElementById("goodbyeModal").style.display = "flex";
          if (reason === "inactivity") {
            // Show a user-friendly alert
            alert("You were logged out due to inactivity. Please sign in again to continue journaling.");
          }
        }, 100);
      }
    }

    // Logout on tab close/refresh
    window.addEventListener("beforeunload", (e) => {
      if (auth.currentUser) {
        // Use navigator.sendBeacon or sync XHR for best effort logout
        // But Firebase signOut is async and may not complete, so just set flag
        localStorage.setItem("userJustLoggedOut", "true");
        // Try to sign out (may not complete)
        auth.signOut();
      }
    });

    // Inactivity auto-logout (15 min), warn user before logout
    let inactivityTimeout = null;
    let warningTimeout = null;
    const INACTIVITY_LIMIT = 15 * 60 * 1000; // 15 min
    const WARNING_TIME = 14 * 60 * 1000; // 14 min (1 min before logout)

    function resetInactivityTimers() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      if (warningTimeout) clearTimeout(warningTimeout);
      // Only set timers if signed in
      if (auth.currentUser) {
        warningTimeout = setTimeout(() => {
          // Show alert 1 min before auto-logout
          alert("You will be logged out soon due to inactivity. Move your mouse or press a key to stay logged in.");
        }, WARNING_TIME);
        inactivityTimeout = setTimeout(() => {
          safeLogout("inactivity");
        }, INACTIVITY_LIMIT);
      }
    }

    // Reset inactivity timer on user activity
    ["mousemove", "keydown", "mousedown", "touchstart"].forEach(evt =>
      window.addEventListener(evt, resetInactivityTimers, true)
    );

    // Reset timers on login/logout state change
    onAuthStateChanged(auth, user => {
      if (user && !user.isAnonymous) {
        resetInactivityTimers();
      } else {
        if (inactivityTimeout) clearTimeout(inactivityTimeout);
        if (warningTimeout) clearTimeout(warningTimeout);
      }
    });

// Move showTab global function here (outside onAuthStateChanged)
window.showTab = function(tabId) {
  const tabs = ["journalTab", "calendarTab"];
  const buttons = {
    journalTab: document.getElementById("journalTabButton"),
    calendarTab: document.getElementById("calendarTabButton")
  };

  tabs.forEach(id => {
    document.getElementById(id).style.display = (id === tabId ? "block" : "none");
    if (buttons[id]) {
buttons[id].style.setProperty("background-color", id === tabId ? "#2A6D6D" : "#FFA76D", "important");      buttons[id].style.color = "white";
    }
  });

  if (tabId === "calendarTab") {
    buildCalendar();
  }
};
// Handle embedded agreement button logic
window.acceptEmbeddedAgreement = async function () {
  const embeddedCheckbox = document.getElementById("embeddedAgreementCheckbox");
  const acceptEmbeddedBtn = document.getElementById("acceptEmbeddedAgreementButton");

  if (!embeddedCheckbox.checked || !window.currentUserId) return;

  try {
    localStorage.setItem("alphaAgreementAccepted", "true");

    await setDoc(doc(db, "users", window.currentUserId), {
      agreementAccepted: true
    }, { merge: true });

    document.getElementById("embeddedAgreementNotice").style.display = "none";
    document.getElementById("journalTab").style.display = "block";
    document.getElementById("tabButtons").style.display = "flex";
    document.querySelector("main").style.display = "block";
  } catch (err) {
    alert("Error saving agreement: " + err.message);
    console.error("Detailed agreement save error:", err);
  }
};


// Enable the Accept button only when checkbox is checked
document.addEventListener("DOMContentLoaded", () => {
  const embeddedCheckbox = document.getElementById("embeddedAgreementCheckbox");
  const acceptEmbeddedBtn = document.getElementById("acceptEmbeddedAgreementButton");

  embeddedCheckbox?.addEventListener("change", () => {
    acceptEmbeddedBtn.disabled = !embeddedCheckbox.checked;
  });
});



    let currentUserId = null;

onAuthStateChanged(auth, async (user) => {
  // DEBUG: Log when onAuthStateChanged handler runs and user object
  console.log("onAuthStateChanged triggered. User object:", user);

  // Always hide the Alpha Agreement modal by default
  document.getElementById("embeddedAgreementNotice").style.display = "none";

  if (!user) {
    const justLoggedOut = localStorage.getItem("userJustLoggedOut") === "true";

    document.getElementById("embeddedAgreementNotice").style.display = "none";
    document.getElementById("journalTab").style.display = "none";
    document.getElementById("tabButtons").style.display = "none";

    if (justLoggedOut) {
      document.getElementById("goodbyeModal").style.display = "flex";
      localStorage.removeItem("userJustLoggedOut");
      document.getElementById("loginModal").style.display = "none";
    } else {
      document.getElementById("loginModal").style.display = "flex";
      document.getElementById("goodbyeModal").style.display = "none";
    }
    document.querySelector("main").style.display = "none";
    return;
  }

  // If anonymous or missing UID, hide Alpha modal and main UI
  if (!user.uid || user.isAnonymous) {
    document.getElementById("embeddedAgreementNotice").style.display = "none";
    document.querySelector("main").style.display = "none";
    return;
  }


  currentUserId = user.uid;
  window.currentUserId = user.uid;

  const userDocRef = doc(db, "users", user.uid);
  const userDoc = await getDoc(userDocRef);

  if (!userDoc.exists()) {
    await setDoc(userDocRef, {
      email: user.email || "",
      createdAt: serverTimestamp(),
      userRole: "journaler",
      agreementAccepted: false
    });
  }


  const statusDiv = document.getElementById("userStatus");
  const displayName = userDoc.data()?.displayName;
  statusDiv.textContent = displayName
    ? `Journaling as: ${displayName}`
    : user.email
      ? `Journaling as: ${user.email}`
      : "Journaling anonymously";

  if (userDoc.data()?.avatarUrl) {
    const avatarImg = document.createElement("img");
    avatarImg.src = userDoc.data().avatarUrl;
    avatarImg.alt = "User Avatar";
    avatarImg.style.width = "40px";
    avatarImg.style.height = "40px";
    avatarImg.style.borderRadius = "50%";
    avatarImg.style.marginLeft = "10px";
    statusDiv.appendChild(avatarImg);
  }

  const agreed = userDoc.data()?.agreementAccepted === true;
  const localAccepted = localStorage.getItem("alphaAgreementAccepted") === "true";
  // DEBUG: Log agreement check state
  console.log("Agreement debug:", {agreed, localAccepted, userDoc: userDoc.data()});
  // Only show Alpha modal if user exists and is not anonymous and hasn't agreed
  if (!agreed && !localAccepted) {
    document.getElementById("embeddedAgreementNotice").style.display = "block";
    document.getElementById("journalTab").style.display = "none";
    document.getElementById("tabButtons").style.display = "none";
    document.getElementById("loginModal").style.display = "none";
    document.getElementById("goodbyeModal").style.display = "none";
    document.querySelector("main").style.display = "none";
    return;
  }

  document.getElementById("embeddedAgreementNotice").style.display = "none";
  document.getElementById("loginModal").style.display = "none";

  document.getElementById("goodbyeModal").style.display = "none";
  document.getElementById("tabButtons").style.display = "flex";
  document.getElementById("journalTab").style.display = "block";
  document.querySelector("main").style.display = "block";
  setTimeout(() => showTab('journalTab'), 20);



  buildCalendar();

  // ✅ Check for new coach replies and show toast if present
  try {
    const entriesRef = collection(db, "journalEntries");
    const q = query(entriesRef, where("userId", "==", currentUserId), where("newCoachReply", "==", true));
    const snap = await getDocs(q);

    if (!snap.empty) {
      const toast = document.createElement("div");
      toast.textContent = "💬 You have a new reply from your coach!";
      toast.style.position = "fixed";
      toast.style.top = "20px";               // Show at top
      toast.style.bottom = "";                // Clear bottom style
      toast.style.left = "50%";
      toast.style.transform = "translateX(-50%)";
      toast.style.backgroundColor = "#FFA76D";
      toast.style.color = "#fff";
      toast.style.padding = "1em 1.5em";
      toast.style.borderRadius = "5px";
      toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
      toast.style.zIndex = "9999";
      document.body.appendChild(toast);
      setTimeout(async () => {
        toast.remove();

        // 🔄 Clear newCoachReply flags from entries
        try {
          for (const doc of snap.docs) {
            await updateDoc(doc.ref, { newCoachReply: false });
          }
          console.log("✅ Cleared newCoachReply flags.");
        } catch (clearErr) {
          console.warn("⚠️ Failed to clear coach reply flags:", clearErr);
        }

      }, 6000);
    }
  } catch (err) {
    console.warn("Coach reply check failed:", err);
  }
});


window.onload = function () {
  window.saveJournalEntry = async function () {
    const textarea = document.getElementById("journal");
    const text = textarea.value.trim();
    // --- Begin: Insert logic to optionally include Sophy's reflection ---
    const includeReflection = document.getElementById("autoInsertReflection")?.checked;
    const sophyText = document.getElementById("sophyInsight")?.textContent || "";
    const finalText = includeReflection ? text + "\n\n[Sophy's Reflection]\n" + sophyText : text;
    // --- End: Insert logic to optionally include Sophy's reflection ---
    if (!text) return alert("Please enter something before saving.");
    showSpinner("saveStatus", "Saving...");

    try {
      // Multiple file upload support
      const fileInput = document.getElementById("attachment");
      const files = Array.from(fileInput.files || []);
      const maxFileSizeMB = 10;
      const previewDiv = document.getElementById("attachmentPreview");
      previewDiv.innerHTML = ""; // Clear previous preview

      // Validate all files for size
      for (const file of files) {
        if (file && file.size > maxFileSizeMB * 1024 * 1024) {
          alert(`File "${file.name}" exceeds ${maxFileSizeMB}MB limit. Please upload a smaller file.`);
          return;
        }
      }

      // Preview all files
      for (const file of files) {
        if (file.type.startsWith("image/")) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const img = document.createElement("img");
            img.src = e.target.result;
            img.alt = file.name;
            img.style.maxWidth = "100px";
            img.style.marginRight = "10px";
            img.style.borderRadius = "5px";
            previewDiv.appendChild(img);
          };
          reader.readAsDataURL(file);
        } else {
          const span = document.createElement("span");
          span.textContent = file.name;
          span.style.display = "inline-block";
          span.style.padding = "0.5em";
          span.style.background = "#eee";
          span.style.borderRadius = "5px";
          previewDiv.appendChild(span);
        }
      }

      // Upload all files to Firebase Storage, collect URLs and names
      let attachments = [];
      for (const file of files) {
        const storageRef = ref(storage, `attachments/${Date.now()}_${Math.random().toString(36).slice(2,8)}_${file.name}`);
        const snapshot = await uploadBytes(storageRef, file);
        const url = await getDownloadURL(snapshot.ref);
        attachments.push({ url, name: file.name });
      }

      const tagsInput = document.getElementById("tags")?.value.trim?.() || "";
      const tags = tagsInput ? tagsInput.split(",").map(tag => tag.trim()) : [];

      // Build entryData, use attachments array if present
      const entryData = {
        text: finalText,
        createdAt: new Date(),
        userId: currentUserId,
        tags
      };
      if (attachments.length > 0) {
        entryData.attachments = attachments;
      }

      const promptText = document.getElementById("generatedPrompt")?.textContent;
      if (promptText?.includes("Sophy suggests:")) {
        entryData.promptUsed = promptText.split(":").slice(1).join(":").trim();
      }

      if (document.getElementById("coachReviewCheckbox")?.checked) {
        entryData.coachReview = true;
      }
      if (document.getElementById("postSaveActions")?.checked) {
        entryData.maybeReviewLater = true;
      }
      if (journalMode === "manifest") {
        tags.push("manifest");
        const manifestText = document.getElementById("manifestInput").value.trim();
        const today = new Date().toISOString().split("T")[0];
        tags.push(`manifestDate:${today}`);
        entryData.contextManifest = manifestText;
      }
      // Add to Firestore and get the new doc ref
      // Always set userId field, and ensure queries always filter by userId
      const docRef = await addDoc(collection(db, "journalEntries"), entryData);
      console.log("📘 Created entry ID:", docRef.id);
      if (entryData.coachReview) {
        try {
          console.log("📨 Notifying coach with entryId:", docRef.id);
          const response = await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/notifyCoachOfTaggedEntry", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ entryId: docRef.id, userId: currentUserId })
          });
          if (!response.ok) {
            throw new Error("Coach notification failed: " + (await response.text()));
          }
          console.log("📬 Coach notified successfully.");
        } catch (notifyErr) {
          console.error("❌ Failed to notify coach:", notifyErr);
        }
      }

      // Call embedding function via HTTPS endpoint with fetch
      try {
        const token = await auth.currentUser.getIdToken(true);
        await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/embedAndStoreEntry", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({ text, entryId: docRef.id })
        });
      } catch (embedErr) {
        console.warn("Embedding error (non-blocking):", embedErr);
      }

      // Show saved confirmation
      saveStatus.innerHTML = "✅ Saved!";
      setTimeout(() => saveStatus.innerHTML = "", 3000);
      document.getElementById("entryStatus").textContent = "Great work! You’ve added another reflection to your journey.";
      // Flash confirmation animation on textarea
      textarea.classList.add("flash-confirmation");
      setTimeout(() => textarea.classList.remove("flash-confirmation"), 1000);

      textarea.value = "";
      fileInput.value = "";
      previewDiv.innerHTML = "";
      if (document.getElementById("tags")) document.getElementById("tags").value = "";
    } catch (e) {
      console.error("Error saving entry: ", e);
      const saveStatus = document.getElementById("saveStatus");
      saveStatus.innerHTML = "❌ Save failed.";
      setTimeout(() => saveStatus.innerHTML = "", 4000);
    }
  };
};

    async function generatePrompt() {
      const topicInput = document.getElementById("promptTopic").value.trim();
      const manifestText = document.getElementById("manifestInput").value.trim();
      let topic = topicInput;

      if (journalMode === "manifest") {
        if (topicInput && manifestText) {
          topic = `My manifest is: "${manifestText}". Please base the prompt on this and also consider: "${topicInput}".`;
        } else if (manifestText) {
          topic = `Please generate a prompt based on my Manifest Statement: "${manifestText}"`;
        } else {
          topic = topicInput || "manifesting";
        }
      }

      const promptElement = document.getElementById("generatedPrompt");
      // Set "Sophy is thinking..." in green italic before fetching
      promptElement.textContent = "Sophy is thinking...";
      promptElement.style.color = "#2A6D6D";
      promptElement.style.fontStyle = "italic";
      try {
        const response = await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/generatePrompt", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ topic })
        });
        if (response.ok) {
          const data = await response.json();
          const prompt = data.prompt.trim();
          promptElement.textContent = `Sophy suggests: "${prompt}"`;
          if (document.getElementById("autoInsertPrompt")?.checked) {
            const textarea = document.getElementById("journal");
            textarea.value = `"${prompt}"\n\n` + textarea.value;
          }
        } else {
          promptElement.textContent = "Sorry, something went wrong fetching the prompt.";
        }
      } catch (e) {
        promptElement.textContent = "Sorry, something went wrong fetching the prompt.";
      }
    }
    import { query, where, orderBy, getDocs, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

    async function loadPastEntries() {
      const pastEntriesContainer = document.getElementById("pastEntries");
      pastEntriesContainer.innerHTML = "<p>Loading entries...</p>";
      const entriesRef = collection(db, "journalEntries");
      const q = query(entriesRef, where("userId", "==", currentUserId), orderBy("createdAt", "desc"));
      let snapshot;
      try {
        snapshot = await getDocs(q);
      } catch (e) {
        pastEntriesContainer.innerHTML = "<p>We’re setting things up behind the scenes. This feature will be available shortly — please check back soon.</p>";
        return;
      }
      if (snapshot.empty) {
        pastEntriesContainer.innerHTML = "<p>No journal entries yet. Try your first reflection — it doesn’t have to be perfect.</p>";
        return;
      }

      function getFileNameFromUrl(url) {
        try {
          const decoded = decodeURIComponent(url.split("?")[0]);
          const parts = decoded.split("/");
          return parts[parts.length - 1] || null;
        } catch {
          return null;
        }
      }
      function getFileExtension(filename) {
        if (!filename) return "";
        const dot = filename.lastIndexOf(".");
        if (dot === -1) return "";
        return filename.substring(dot + 1).toLowerCase();
      }
      function isImageExtension(ext) {
        return ["jpg", "jpeg", "png", "gif", "webp", "bmp"].includes(ext);
      }

      const entriesHtml = [];
      for (const doc of snapshot.docs) {
        const entry = doc.data();
        // Skip entries with missing or invalid createdAt
        if (!entry.createdAt?.toDate) {
          console.warn("Skipping entry with missing or invalid createdAt:", entry);
          continue;
        }

        // Only entries with valid createdAt reach here
        const date = entry.createdAt.toDate().toLocaleString();
        const tags = entry.tags ? `<p style="font-size: 0.85em; color: #666;">Tags: ${entry.tags.join(", ")}</p>` : "";
        // Highlight Manifest-tagged entries
        const isManifest = entry.tags?.includes("manifest");
        const manifestBadge = isManifest
          ? `<p style="font-size: 0.85em; color: #2A6D6D; font-style: italic;">✨ Reflecting on Manifest: "${entry.contextManifest || ''}"</p>`
          : "";
        const coachTag = entry.coachReview
          ? `<p style="font-size: 0.85em; color: #2A6D6D;">🔓 Shared with coach</p>`
          : "";

        const futureFlag = entry.maybeReviewLater
        const coachReplyNotice = entry.newCoachReply
          ? `<p style="font-size: 0.85em; color: #FFA76D;">💬 New coach reply</p>`
          : "";

        // Attachment rendering logic (multiple or legacy single attachment)
        let attachmentHtml = "";
        if (Array.isArray(entry.attachments) && entry.attachments.length > 0) {
          // Multiple attachments
          attachmentHtml = `<div style="margin-top:0.5em; display: flex; flex-wrap: wrap; gap: 0.5em;">`;
          for (const file of entry.attachments) {
            const filename = file.name || getFileNameFromUrl(file.url);
            const ext = getFileExtension(filename);
            if (isImageExtension(ext)) {
              attachmentHtml += `
                <div style="display:inline-block; text-align:center;">
                  <img src="${file.url}" alt="${filename || 'Attachment'}" style="max-width:80px; max-height:80px; border-radius:4px; border:1px solid #ddd; display:block; margin-bottom:0.25em;" />
                  <a href="${file.url}" target="_blank" style="font-size:0.85em; color:#2A6D6D; text-decoration:underline; display:block;">${filename}</a>
                </div>
              `;
            } else {
              attachmentHtml += `
                <div style="display:inline-block;">
                  <a href="${file.url}" target="_blank" style="font-size:0.95em; color:#2A6D6D; text-decoration:underline;">${filename}</a>
                </div>
              `;
            }
          }
          attachmentHtml += `</div>`;
        } else if (entry.attachmentUrl) {
          // Legacy single attachment
          let filename = getFileNameFromUrl(entry.attachmentUrl);
          // If filename is missing or looks like a generic storage token, fallback to label
          if (!filename || filename.match(/^(\d+_)?[a-z0-9]{6,}(\.[a-z0-9]+)?$/i) === null && !filename.includes('.')) {
            filename = null;
          }
          const ext = getFileExtension(filename);
          if (isImageExtension(ext)) {
            // Display image thumbnail
            attachmentHtml = `<div style="margin-top:0.5em;">
                <img src="${entry.attachmentUrl}" alt="${filename || 'Attachment'}" style="max-width:80px; max-height:80px; border-radius:4px; border:1px solid #ddd; display:block; margin-bottom:0.25em;" />
                <a href="${entry.attachmentUrl}" target="_blank" style="font-size:0.85em; color:#2A6D6D; text-decoration:underline;">View Full Image</a>
              </div>`;
          } else {
            // Display download link with filename if possible, fallback to "Download Attachment"
            const label = filename || "Download Attachment";
            attachmentHtml = `<div style="margin-top:0.5em;">
                <a href="${entry.attachmentUrl}" target="_blank" style="font-size:0.95em; color:#2A6D6D; text-decoration:underline;">${label}</a>
              </div>`;
          }
        }

        entriesHtml.push(`
          <div style="margin-bottom: 1em; padding: 1em; border: 1px solid #ccc; border-radius: 5px;">
            <p style="font-size: 0.9em; color: #999;">${date}</p>
            ${manifestBadge}
            ${coachTag}
            ${futureFlag}
            ${coachReplyNotice}
            <div class="entry-preview">${entry.text}</div>
            <button class="btn" style="margin-top: 0.5em;" onclick="this.previousElementSibling.classList.toggle('entry-preview'); this.textContent = this.textContent === 'Read more' ? 'Collapse' : 'Read more';">Read more</button>
            ${attachmentHtml}
            ${tags}
            
            ${entry.newCoachReply ? `
  <div class="coach-reply" style="margin-top: 1em; padding: 0.75em; border-left: 4px solid #FFA76D; background-color: #fff3ea; font-size: 0.95em;">
    <strong>Coach replied:</strong>
    <p>${entry.coachReplyText || "Your coach has replied. Expand to read more."}</p>
  </div>
` : ""}
            <button class="btn" onclick="editEntry('${doc.id}', \`${entry.text.replace(/`/g, "\\`")}\`)">Edit</button>
            <button class="btn" onclick="deleteEntry('${doc.id}')">Delete</button>

          </div>
        `);
      }

      pastEntriesContainer.innerHTML = entriesHtml.join("");
    }

    window.deleteEntry = async function (docId) {
      if (!confirm("Are you sure you want to delete this entry?")) return;
      try {
        // Only allow deleting if the entry belongs to the current user
        const entryRef = doc(db, "journalEntries", docId);
        const entrySnap = await getDoc(entryRef);
        if (!entrySnap.exists() || entrySnap.data().userId !== currentUserId) {
          alert("You do not have permission to delete this entry.");
          return;
        }
        await deleteDoc(entryRef);
        loadPastEntries(); // Refresh view
      } catch (err) {
        console.error("Error deleting entry:", err);
      }
    };

    window.editEntry = async function (docId, currentText) {
      const newText = prompt("Edit your entry:", currentText);
      if (!newText) return;
      try {
        // Only allow editing if the entry belongs to the current user
        const entryRef = doc(db, "journalEntries", docId);
        const entrySnap = await getDoc(entryRef);
        if (!entrySnap.exists() || entrySnap.data().userId !== currentUserId) {
          alert("You do not have permission to edit this entry.");
          return;
        }
        await updateDoc(entryRef, { text: newText });
        loadPastEntries(); // Refresh view
      } catch (err) {
        console.error("Error updating entry:", err);
      }
    };

    // async function loadJournalTimeline() {
    //   // Disabled: #journalTimeline element no longer exists in HTML.
    //   // This function is commented out to prevent console errors.
    //   // If needed in the future, restore and provide a corresponding HTML element.
    // }


    async function signUp() {
      const email = document.getElementById("emailInput").value;
      const password = document.getElementById("passwordInput").value;
      try {
        await createUserWithEmailAndPassword(auth, email, password);

        await setDoc(doc(db, "users", auth.currentUser.uid), {
  email: auth.currentUser.email,
  userRole: "journaler",
  agreementAccepted: false
});
       
        // TODO: Allow users to set a display name and avatar image for personalization
        document.getElementById("loginModal").style.display = "none";
        document.getElementById("userStatus").textContent = `Journaling as: ${auth.currentUser.email}`;
      } catch (err) {
        alert("Error signing up: " + err.message);
      }
    }

    async function signIn() {
      const email = document.getElementById("emailInput").value;
      const password = document.getElementById("passwordInput").value;
      try {
        await signInWithEmailAndPassword(auth, email, password);
        
        document.getElementById("loginModal").style.display = "none";
        // UI state will be managed by onAuthStateChanged
      } catch (err) {
        alert("Login failed: " + err.message);
      }
    }

    
    let journalMode = 'manifest';

window.setJournalMode = function (mode) {
  journalMode = mode;
  const manifestBtn = document.getElementById("manifestModeButton");
  const freeBtn = document.getElementById("freeModeButton");

  if (mode === "manifest") {
    manifestBtn.style.backgroundColor = "#2A6D6D";
    manifestBtn.style.color = "white";
    freeBtn.style.backgroundColor = "#ccc";
    freeBtn.style.color = "#333";
  } else {
    freeBtn.style.backgroundColor = "#2A6D6D";
    freeBtn.style.color = "white";
    manifestBtn.style.backgroundColor = "#ccc";
    manifestBtn.style.color = "#333";
  }
};

    function showTab(tabId) {
      const tabs = ["journalTab", "calendarTab"];
      const buttons = {
        journalTab: document.getElementById("journalTabButton"),
        calendarTab: document.getElementById("calendarTabButton")
      };

      // Find the currently active tab
      let activeTab = null;
      tabs.forEach(id => {
        if (document.getElementById(id).style.display !== "none") {
          activeTab = id;
        }
      });

      // Only switch if not already on this tab
      if (activeTab === tabId) {
        // Already active, do nothing
        return;
      }

      tabs.forEach(id => {
        document.getElementById(id).style.display = (id === tabId ? "block" : "none");
        if (buttons[id]) {
          buttons[id].style.backgroundColor = (id === tabId ? "#2A6D6D" : "#FFA76D");
          buttons[id].style.color = (id === tabId ? "white" : "white");
        }
      });
      if (tabId === "calendarTab") {
        // Always build calendar when switching to calendarTab
        buildCalendar();
        document.getElementById("calendarEntries") && (document.getElementById("calendarEntries").innerHTML = "<p>Click a calendar date to view entries.</p>");
        document.getElementById("searchResults") && (document.getElementById("searchResults").innerHTML = "<p>Use Smart Search to explore your journal history.</p>");
      } else if (tabId === "journalTab") {
        const manifestInput = document.getElementById("manifestInput");
        if (manifestInput && window.currentUserId) {
          // Always read manifest using the user's UID as the doc ID
          getDoc(doc(db, "manifests", window.currentUserId))
            .then(manifestDoc => {
              if (manifestDoc.exists()) {
                manifestInput.value = manifestDoc.data().statement || "";
                console.log("✅ Manifest loaded from showTab.");
              } else {
                console.log("ℹ️ No manifest found for this user.");
              }
            })
            .catch(err => {
              console.error("❌ Error loading manifest:", err);
            });
        }
      }
    }


    // (showTab('journalTab') is now only called in onAuthStateChanged after UI is shown)

// Make calendar month/year globals so they persist and are accessible
window.displayedMonth = new Date().getMonth();
window.displayedYear = new Date().getFullYear();

// Calendar build function
async function buildCalendar() {
  const container = document.getElementById("calendarContainer");
  container.innerHTML = "";

  // Fetch journal entry dates for current month/year
  // Only fetch entries for the current user
  const snapshot = await getDocs(query(
    collection(db, "journalEntries"),
    where("userId", "==", currentUserId)
  ));

  const markedDates = new Set();
  snapshot.forEach(doc => {
    const createdAt = doc.data().createdAt?.toDate?.();
    if (createdAt &&
        createdAt.getFullYear() === window.displayedYear &&
        createdAt.getMonth() === window.displayedMonth) {
      const key = `${createdAt.getFullYear()}-${String(createdAt.getMonth() + 1).padStart(2, '0')}-${String(createdAt.getDate()).padStart(2, '0')}`;
      markedDates.add(key);
    }
  });

  // Month/Year heading
  const currentMonthHeading = document.createElement("h3");
  const tempDate = new Date(window.displayedYear, window.displayedMonth, 1);
  currentMonthHeading.textContent = `${tempDate.toLocaleString('default', { month: 'long' })} ${window.displayedYear}`;
  currentMonthHeading.style.textAlign = "center";
  currentMonthHeading.style.color = "#2A6D6D";
  currentMonthHeading.style.marginTop = "1em";

  container.appendChild(currentMonthHeading);

  const calendarTable = document.createElement("table");
  calendarTable.style.width = "100%";
  calendarTable.style.textAlign = "center";
  calendarTable.style.borderCollapse = "collapse";
  calendarTable.style.marginTop = "1em";

  const headerRow = document.createElement("tr");
  const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  days.forEach(day => {
    const th = document.createElement("th");
    th.textContent = day;
    th.style.padding = "0.5em";
    headerRow.appendChild(th);
  });
  calendarTable.appendChild(headerRow);

  const firstDay = new Date(window.displayedYear, window.displayedMonth, 1).getDay();
  const daysInMonth = new Date(window.displayedYear, window.displayedMonth + 1, 0).getDate();

  let row = document.createElement("tr");
  for (let i = 0; i < firstDay; i++) {
    row.appendChild(document.createElement("td"));
  }

  for (let day = 1; day <= daysInMonth; day++) {
    if ((row.children.length % 7) === 0) {
      calendarTable.appendChild(row);
      row = document.createElement("tr");
    }
    const td = document.createElement("td");
    td.textContent = day;
    td.style.cursor = "pointer";
    td.style.padding = "0.5em";
    td.style.border = "1px solid #ccc";
    // Add highlight if this day has a journal entry
    const key = `${window.displayedYear}-${String(window.displayedMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    if (markedDates.has(key)) {
      td.style.backgroundColor = "#FFE5B4"; // Light highlight to mark the date
      td.title = "Journal entry";
    }
    td.onclick = () => showPromptsByDate(window.displayedYear, window.displayedMonth, day);
    row.appendChild(td);
  }
  calendarTable.appendChild(row);
  container.appendChild(calendarTable);
}

// Ensure changeMonth is in global scope and updates displayedMonth/year, then calendar
window.changeMonth = function(offset) {
  window.displayedMonth += offset;
  if (window.displayedMonth < 0) {
    window.displayedMonth = 11;
    window.displayedYear--;
  } else if (window.displayedMonth > 11) {
    window.displayedMonth = 0;
    window.displayedYear++;
  }
  buildCalendar();
};

async function showPromptsByDate(year, month, day) {
  const container = document.getElementById("pastEntries");
  const selectedDate = new Date(year, month, day).toDateString();
  container.innerHTML = `<p><strong>Entries from ${selectedDate}:</strong></p>`;

  const journalRef = collection(db, "journalEntries");
  // Only fetch entries for the current user
  const snapshot = await getDocs(query(journalRef, where("userId", "==", currentUserId)));

  const matches = [];
  snapshot.forEach((doc) => {
    const data = doc.data();
    const savedDate = data.createdAt?.toDate().toDateString();
    if (savedDate === selectedDate) {
      const hasReply = !!data.coachResponse?.text;
      const replyBlock = hasReply
        ? `<div style="margin-top:0.5em; font-size:0.9em; background:#fff3ea; border-left:4px solid #FFA76D; padding:0.5em;">
             <strong>Coach replied:</strong> ${data.coachResponse.text}
           </div>`
        : "";
      matches.push({
        text: data.text,
        contextManifest: data.contextManifest,
        replyBlock,
        createdAt: data.createdAt?.toDate?.() || null
      });
    }
  });

  if (matches.length === 0) {
    container.innerHTML += "<p>No entries found.</p>";
  } else {
    const ul = document.createElement("ul");
   matches.forEach(entry => {
  const li = document.createElement("li");
  li.innerHTML = `
    ${entry.contextManifest ? '✨ ' : ''}
    <div class="entry-preview"><em>${entry.text}</em></div>
    ${entry.replyBlock || ""}
    <button class="btn" style="margin-top: 0.5em;" onclick="this.previousElementSibling.classList.toggle('entry-preview'); this.textContent = this.textContent === 'Read more' ? 'Collapse' : 'Read more';">Read more</button>
  `;
  ul.appendChild(li);
});
    container.appendChild(ul);
  }
}


    // Expose functions for UI onclick attributes
    window.generatePrompt = generatePrompt;
    window.signUp = signUp;
    window.signIn = signIn;

// Modal close function for login modal
window.loginModalClose = function () {
  document.getElementById("loginModal").style.display = "none";
  document.querySelector("main").style.display = "none";

  // Optional toast-like feedback
  const toast = document.createElement("div");
  toast.textContent = "You must log in to access the journal.";
  toast.style.position = "fixed";
  toast.style.bottom = "20px";
  toast.style.left = "50%";
  toast.style.transform = "translateX(-50%)";
  toast.style.backgroundColor = "#FFA76D";
  toast.style.color = "#fff";
  toast.style.padding = "1em 1.5em";
  toast.style.borderRadius = "5px";
  toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
  toast.style.zIndex = "9999";
  document.body.appendChild(toast);
  setTimeout(() => {
    toast.remove();
  }, 4000);
};

window.showLoginModal = function () {
  document.getElementById("goodbyeModal").style.display = "none";
  document.getElementById("loginModal").style.display = "flex";
  document.getElementById("emailInput").value = "";
  document.getElementById("passwordInput").value = "";
};

window.showSpinner = function (targetId, message = "Working...") {
  const el = document.getElementById(targetId);
  if (el) {
    el.innerHTML = `<span class="spinner"></span> ${message}`;
  }
};

window.logOutUser = async function () {
  console.log("Logout started.");
  try {
    localStorage.setItem("userJustLoggedOut", "true");
    await auth.signOut();
    document.querySelector("main").style.display = "none";
    
    document.getElementById("embeddedAgreementNotice").style.display = "none";
    setTimeout(() => {
      const modal = document.getElementById("goodbyeModal");
      if (modal) {
        modal.style.display = "flex";
        modal.style.position = "fixed";
        modal.style.top = "0";
        modal.style.left = "0";
        modal.style.width = "100vw";
        modal.style.height = "100vh";
        modal.style.background = "rgba(0,0,0,0.8)";
        modal.style.color = "#2A6D6D";
        modal.style.alignItems = "center";
        modal.style.justifyContent = "center";
        modal.style.zIndex = "9999";
      }
    }, 100);
  } catch (err) {
    console.error("Logout failed:", err);
    alert("Logout failed.");
  }
};
async function askSophyAboutEntry() {
  const journalText = document.getElementById("journal").value.trim();
  const sophyInsight = document.getElementById("sophyInsight");

  if (!journalText) {
    sophyInsight.textContent = "Please write something in your journal first.";
    return;
  }
  sophyInsight.textContent = "Sophy is thinking...";
  try {
    const response = await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/askSophy", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ entry: journalText })
    });

    if (!response.ok) throw new Error("Failed to fetch insight.");

    const data = await response.json();
    const insight = data.insight?.trim?.() || "Sophy couldn't generate a reflection right now.";
    sophyInsight.textContent = insight;

  } catch (err) {
    console.error("Error fetching Sophy insight:", err);
    sophyInsight.textContent = "Sorry, Sophy couldn't reflect right now.";
  }
}

    window.askSophyAboutEntry = askSophyAboutEntry;

    // Manifest save function
    window.saveManifest = async function () {
      // Always use current user's UID for manifest doc
      let user = null;
      try {
        user = auth.currentUser;
      } catch (e) {
        user = null;
      }
      const text = document.getElementById("manifestInput").value.trim();
      const status = document.getElementById("manifestStatus");

      if (!user || !text) {
        status.textContent = "You must be logged in and enter a statement to save.";
        status.style.color = "red";
        return;
      }

      window.showSpinner("manifestStatus", "Saving...");

      try {
        // Always use user's UID as doc ID for manifests
        await setDoc(doc(db, "manifests", user.uid), {
          statement: text,
          timestamp: serverTimestamp()
        });
        status.innerHTML = "✅ Vision saved. You're building something meaningful.";
        status.style.color = "#2A6D6D";
      } catch (error) {
        console.error("Error saving manifest:", error);
        status.textContent = "Failed to save manifest.";
        status.style.color = "red";
      }
    };

    // Refine Manifest with Sophy
window.askSophyToRefineManifest = async function () {
  const text = document.getElementById("manifestInput").value.trim();
  const status = document.getElementById("manifestStatus");
  if (!text) {
    status.textContent = "Please write something first for Sophy to refine.";
    status.style.color = "red";
    return;
  }

  // Set Sophy "thinking" status before making the request
  status.textContent = "Sophy is thinking...";
  status.style.color = "#2A6D6D";

  try {
    const res = await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/askSophy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ entry: `Help me improve this personal guiding statement: "${text}"` })
    });
    const data = await res.json();
    if (data.insight) {
      document.getElementById("manifestSuggestion").value = data.insight;
      status.textContent = "Sophy's ideas are available.";
      status.style.color = "#2A6D6D";
    } else {
      throw new Error(data.insight || "No insight returned.");
    }
  } catch (err) {
    console.error("Error fetching refinement:", err);
    status.textContent = "Failed to get Sophy's help.";
    status.style.color = "red";
  }
};
// Ensure calendar is built after defining all functions
// (Note: initial buildCalendar and showTab('journalTab') are called by auth listener after login)
  </script>
</head>
<body>
  <header>
  <div id="goodbyeModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: #2A6D6D; display: none; align-items: center; justify-content: center; z-index: 9999;">
    <div class="card-block" style="max-width: 500px; width: 90%; text-align: center;">
      <h2 class="section-header">See You Soon!</h2>
      <p>Thanks for journaling with InkWell today.</p>
      <p>Take care, and don’t forget to stay positive.</p>
<button class="btn" onclick="showLoginModal()" style="margin-top: 1.5em;">Return to Login</button>    
</div>
  </div>
    <img src="/InkWell Logo NoBG.png" alt="InkWell Logo" style="max-height: 120px; margin-bottom: 1em;" />
    <p>Your space to reflect, write, and grow.</p>
  </header>
  <div id="userStatus" style="font-size: 0.9em; margin-bottom: 1em;"></div>


  <div id="embeddedAgreementNotice">
    <div class="card-block">
      <h3 class="section-header" style="color: #FFA76D;">Action Required: Accept Alpha Testing Agreement</h3>
      <p style="font-size: 0.9em;">Before you can use InkWell, please review and agree to the following:</p>
      <div style="display: flex; flex-direction: column; gap: 0.5em; align-items: center; margin-bottom: 1em;">
  <a href="https://www.pegasusrealm.com/terms-conditions/" target="_blank" style="text-align: center;">Terms & Conditions</a>
  <a href="https://www.pegasusrealm.com/privacy-policy/" target="_blank" style="text-align: center;">Privacy Policy</a>
  <a href="https://www.pegasusrealm.com/alpha-beta-testers/" target="_blank" style="text-align: center;">Alpha/Beta Tester Agreement</a>
</div>
      <label style="display: block; margin-top: 1em;">
        <input type="checkbox" id="embeddedAgreementCheckbox" />
        I have read and agree to all three terms listed above.
      </label>
      <button class="btn" onclick="acceptEmbeddedAgreement()" id="acceptEmbeddedAgreementButton" disabled>Accept & Continue</button>
    </div>
  </div>

  <div id="loginModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 9999;">
    <div class="card-block" style="max-width: 400px; width: 90%; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);">
      <h3 class="section-header" style="text-align: center;">Login or Sign Up</h3>
      <input type="email" id="emailInput" placeholder="Email" autocomplete="off" ... />
<input type="password" id="passwordInput" placeholder="Password" autocomplete="off" ... />
      <button class="btn" onclick="signUp()" style="width: 100%; margin-bottom: 0.5em;">Sign Up</button>
      <button class="btn" onclick="signIn()" style="width: 100%;">Sign In</button>
      <button class="btn" onclick="loginModalClose()" style="width: 100%; margin-top: 1em;">Close</button>
    </div>
  </div>
  <main style="display: block;">
    <div id="tabButtons" style="display: flex; gap: 1em; margin-bottom: 1em;">
        <button class="btn" id="journalTabButton" onclick="showTab('journalTab')" style="flex: 1;">Journal</button>
        <button class="btn" id="calendarTabButton" onclick="showTab('calendarTab')" style="flex: 1;">Past Entries</button>
      </div>
    <div id="journalTab">
      <div class="card-block">
        <h3 class="section-header" style="text-align: center;">Your Manifest Statement</h3>
        <p style="font-size: 1em; line-height: 1.6; margin-top: 1em;">
          This Manifest Statement is your personal guiding goal or vision. It is visible to your coach and to Sophy so they can help you stay aligned and work toward it. You can ask Sophy or a coach to help you write or refine this statement at any time.
        </p>
        <textarea id="manifestInput" placeholder="Write your personal guiding statement..." style="width: 100%; height: 100px; margin-bottom: 0.5em; padding: 0.5em; border-radius: 5px; border: 1px solid #ccc;"></textarea>
        
        <p id="manifestStatus" style="margin-top: 0.5em; font-style: italic;"></p>
        <button class="btn" onclick="askSophyToRefineManifest()">Refine with Sophy</button>
        <p id="manifestSuggestionLabel" style="font-weight: bold; margin-top: 1em;">Sophy’s Suggested Refinement:</p>
        <textarea id="manifestSuggestion" readonly style="width: 100%; height: 100px; margin-bottom: 0.5em; padding: 0.5em; border-radius: 5px; border: 1px dashed #aaa; background-color: #fdfdfd;"></textarea>
        <button class="btn" onclick="saveManifest()">Save</button>
      </div>
      <div class="card-block">
        <!-- (Sophy prompt block moved below) -->
      </div>
      <div class="card-block">
        <h3 class="section-header" style="text-align: center;">Your Journal</h3>
        <p>
          Use this space to reflect on your Manifest Statement or free journal. Below, you'll find optional tools to enhance your entry — you can ask Sophy for a writing prompt or upload images and files to enrich your thoughts or support your manifesting process.
        </p>
        <div id="journalModeToggle" style="display: flex; justify-content: center; gap: 1em; margin-bottom: 2em; padding-bottom: 0.5em;">
          <button class="btn" id="manifestModeButton" onclick="setJournalMode('manifest')" style="flex: 1; background-color: #2A6D6D; color: white;">Focus on Manifesting</button>
          <button class="btn" id="freeModeButton" onclick="setJournalMode('free')" style="flex: 1; background-color: #ccc; color: #333;">Free Journal</button>
        </div>
        <!-- (Attachment input and preview moved below) -->
            <p class="subtext-muted" style="margin-top: 1em;">If you want a topic or some inspiration, <strong>Sophy</strong> can suggest ideas — you can even give her a topic to focus on.</p>
      <input type="text" id="promptTopic" placeholder="Enter a topic, mood, or leave blank" style="width: 100%; margin-bottom: 0.5em; padding: 0.5em; border-radius: 5px; border: 1px solid #ccc;" />
      <button class="btn" onclick="generatePrompt()">Ask Sophy for a Prompt</button>
      <p id="generatedPrompt" style="font-style: italic; color: #2A6D6D; margin-top: 0.5em; padding-left: 1em;">
        Sophy's suggestion will appear here.
      </p>
      <label style="font-size: 0.85em; display: block; margin-top: 0.5em; margin-bottom: 0.5em;">
        <input type="checkbox" id="autoInsertPrompt" checked />
        Include this prompt in my journal
      </label>

      

<label for="journal" style="margin-top:1em; display:block; font-weight:600;">Journal Entry:</label>
<textarea id="journal" placeholder="Write your thoughts here..." style="width: 100%; box-sizing: border-box; margin-bottom: 0.5em;"></textarea>
<label style="font-size: 0.85em; display: block; margin-top: 0.5em;">
  <input type="checkbox" id="autoInsertReflection" checked />
  Include Sophy's reflection in my journal
</label>

<div id="entryStatus" style="font-size: 0.85em; color: #2A6D6D; margin-top: 0.5em;"></div>
<div id="sophyInsight" style="font-style: italic; color: #2A6D6D; margin: 1em 0; white-space: pre-wrap;">
  Sophy's Reflection will appear here after you ask for guidance.
</div>
<button class="btn" onclick="askSophyAboutEntry()">Ask Sophy for Reflection</button>

<label for="attachment" style="margin-top: 1em; display: block;">Attach a photo or file:</label>
<input type="file" id="attachment" accept=".png,.jpg,.jpeg,.gif,.pdf,.doc,.docx,image/*" style="margin-bottom: 1em;" multiple /><div id="attachmentPreview" style="margin-bottom: 1em;"></div>

<!-- Move coach review checkbox here, above Save button -->
<label style="font-size: 0.85em; display: block; margin-top: 1em; margin-bottom: 0.5em;">
  <input type="checkbox" id="coachReviewCheckbox" />
  Tag this entry for my coach
</label>

<button class="btn" onclick="saveJournalEntry()" style="margin-top: 0.5em;">Save Journal Entry</button>
<span id="saveStatus" style="margin-left: 10px; font-style: italic;"></span>
      </div>
    </div>
<div id="calendarTab" style="display: none;">
  <div class="card-block">
    <h3 class="section-header" style="text-align: center; color: #2A6D6D;">Journal Calendar</h3>
    <div id="calendarControls" style="text-align: center; margin-bottom: 1em;">
      <button class="btn" onclick="changeMonth(-1)">← Previous</button>
      <button class="btn" onclick="changeMonth(1)">Next →</button>
    </div>
    <div id="calendarContainer"></div>
    <div id="pastEntries" style="margin-top: 1em;"></div>

    <!-- Smart Search Bar UI -->
    <div class="card-block" style="margin-top: 2em;">
      <h3 class="section-header">Smart Search Your Journal</h3>
      <input type="text" id="searchQuery" placeholder="e.g., burnout last week, goals, feeling stuck" style="width: 100%; padding: 0.5em; margin-bottom: 0.5em; border-radius: 5px; border: 1px solid #ccc;" />
      <button class="btn" onclick="runSmartSearch()">Search</button>
      <div id="searchResults" style="margin-top: 1em;"></div>
    </div>
    <script>
      // Smart search: embed query, fetch all entries, compare embeddings, sort by similarity, show top 5
      async function runSmartSearch() {
        // Ensure callable wrappers are defined
const logQuery = async ({ query }) => {
  try {
    await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/logSearchQuery", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ query })
    });
  } catch (err) {
    console.warn("Failed to log query (non-blocking):", err);
  }
};        const queryText = document.getElementById("searchQuery").value.trim();
        const resultsContainer = document.getElementById("searchResults");
        showSpinner("searchResults", "Searching...");
        if (!queryText || !auth?.currentUser?.uid) {
          resultsContainer.innerHTML = "<p>Please enter a search phrase.</p>";
          return;
        }
        try {
          // Log the search query with Firebase callable function before embedding
          await logQuery({ query: queryText });
          // 1. Embed the query using HTTPS endpoint directly, with ID token
          const user = auth.currentUser;
          if (!user) throw new Error("User not authenticated.");
          const idToken = await user.getIdToken();
          const embedResp = await fetch("https://us-central1-inkwell-alpha.cloudfunctions.net/embedAndStoreEntry", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${idToken}`
            },
            body: JSON.stringify({ text: queryText })
          });
          if (!embedResp.ok) {
            throw new Error("Failed to get embedding for query.");
          }
          const embedResult = await embedResp.json();
          const queryEmbedding = embedResult.embedding;
          if (!queryEmbedding || !Array.isArray(queryEmbedding)) {
            throw new Error("Failed to get embedding for query.");
          }
          // 2. Fetch all user's journal entries with embeddings
          const entriesRef = collection(db, "journalEntries");
          const q = query(entriesRef, where("userId", "==", currentUserId));
          const snapshot = await getDocs(q);
          const entries = [];
          snapshot.forEach(docSnap => {
            const data = docSnap.data();
            // Only consider entries with an embedding array
            if (Array.isArray(data.embedding)) {
              entries.push({
                id: docSnap.id,
                text: data.text,
                tags: data.tags,
                createdAt: data.createdAt,
                embedding: data.embedding,
                contextManifest: data.contextManifest
              });
            }
          });
          if (entries.length === 0) {
            resultsContainer.innerHTML = "<p>No entries with embeddings found. Try saving a new entry first.</p>";
            return;
          }
          // 3. Calculate cosine similarity for each entry
          function cosineSimilarity(a, b) {
            let dot = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
              dot += a[i] * b[i];
              normA += a[i] * a[i];
              normB += b[i] * b[i];
            }
            if (normA === 0 || normB === 0) return 0;
            return dot / (Math.sqrt(normA) * Math.sqrt(normB));
          }
          for (const entry of entries) {
            entry.sim = cosineSimilarity(queryEmbedding, entry.embedding);
          }
          // 4. Sort by similarity descending, pick top 5
          const top = entries.sort((a, b) => b.sim - a.sim).slice(0, 5);
          // 5. Render results
          if (top.length === 0) {
            resultsContainer.innerHTML = "<p>No similar entries found.</p>";
            return;
          }
          let html = "<ol>";
          for (const entry of top) {
            const dateStr = entry.createdAt?.toDate?.().toLocaleString?.() || "";
            html += `<li style="margin-bottom: 1em;">
              <div style="font-size:0.85em; color:#999;">${dateStr}</div>
              ${entry.contextManifest ? `<div style="font-size:0.85em; color:#2A6D6D;">✨ Manifest: "${entry.contextManifest}"</div>` : ""}
              <div class="entry-preview">${entry.text}</div>
              <div style="font-size:0.8em; color:#888;">Similarity: ${(entry.sim*100).toFixed(1)}%</div>
              ${entry.tags ? `<div style="font-size:0.8em; color:#666;">Tags: ${entry.tags.join(", ")}</div>` : ""}
            </li>`;
          }
          html += "</ol>";
          resultsContainer.innerHTML = html;
        } catch (err) {
          console.error("Smart search error:", err);
          document.getElementById("searchResults").innerHTML = "<p>Sorry, something went wrong with smart search.</p>";
        }
      }
    </script>

  </div>
</div>
  </main>
  <div style="text-align: center; margin-top: 2em;">
    <button class="btn" onclick="logOutUser()">Logout</button>
  </div>
  <footer style="margin-top: 2em; font-size: 0.85em; text-align: center;">
    <p>© 2025 Pegasus Realm LLC. InkWell. All rights reserved.</p>
    <p>
      <a href="https://www.inkwelljournal.io/privacy-policy/" target="_blank" style="text-decoration: underline; color: #2A6D6D;">Privacy Policy</a> |
      <a href="https://www.inkwelljournal.io/terms-conditions/" target="_blank" style="text-decoration: underline; color: #2A6D6D;">Terms and Conditions</a> |
      <a href="https://www.inkwelljournal.io/alpha-beta-testers/" target="_blank" style="text-decoration: underline; color: #2A6D6D;">Alpha/Beta Tester Agreement</a>
    </p>
    <p>Contact support: <a href="mailto:support@inkwelljournal.io" style="text-decoration: underline; color: #2A6D6D;">support@inkwelljournal.io</a></p>
  </footer>
</body>
</html>

